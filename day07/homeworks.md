# 宿題1
## 行列積のループ順序としては6種類の組み合わせがあるが、実行速度が早いと思う方から順に並べてみよ。
```
c[i][j]=a[i][k]*b[k][j]
```
である。ここで、$n^3$回アクセスをしなければならない一番内側のループにおいて、

|     |同一のメモリにアクセス   |連続したメモリにアクセス   |n個ずつ飛んだメモリにアクセス  |
|i-j-k|c                    |a                      |b                          |
|i-k-j|a                    |b,c                   |                           |
|j-i-k|c                    |a                      |b                        |
|j-k-i|b                   |                       |a,c                          |
|k-i-j|a                    |b,c                    |                           |
|k-j-i|b                   |                       |a,c                           |

ここで、CPUは連続的なメモリアクセスを検知すると、相当先のデータまでCPUキャッシュおよびCPUレジスタに先読みしてくれるので、「同一のメモリにアクセス」と「連続したメモリにアクセス」ではあまり速度が変わらないはずである。よって、n個ずつ飛んだメモリにアクセスしないといけないものが多いものから順に時間がかかるはず。真ん中のループと外側のループを実行する回数は一番内側のループに比べて1/N以下であるので、そこについては一番内側のループに比べ影響がはるかに小さいだろう。
よって表より、
(j-k-i)=(k-j-i)>(i-j-k)=(j-i-k)>(i-k-j)=(k-i-j)


## 予想が正しいか確かめよ。
matrix.cをN=1024で動かした結果は以下のようになる。
```
(j-k-i)time: 20.989250 sec
(k-j-i)time: 20.262543 sec
(i-j-k)time: 20.189388 sec
(j-i-k)time: 15.990268 sec
(i-k-j)time: 5.114913 sec
(k-i-j)time: 3.891664 sec
```
結果は、(j-k-i)≒(k-j-i)≒(i-j-k)≒(j-i-k)＞(i-k-j)≒(k-i-j)
順番は予想と一致したが、n個ずつ飛んだメモリが2このもの(j-k-i),(k-j-i)と、1個のもの(i-j-k)(j-i-k)であまり速度に差が見られなかった。なぜだろうか…

# 宿題2
## pythonで書くとあまり速度が変わらない理由
インタプリタ言語なので、ループを回すたびにその中の文章を解釈し直している。そちらの方がメモリアクセスより時間がかかっているので、メモリアクセスの回数による速度の違いが顕著には現れないから。